'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.cjs');

/**
 * Gets the OneKey Stellar provider from the window object
 */
const getOneKeyStellarProvider = () => {
    if (typeof window === 'undefined') {
        return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const onekey = window.$onekey;
    if (!(onekey === null || onekey === void 0 ? void 0 : onekey.stellar)) {
        return undefined;
    }
    return onekey.stellar;
};
/**
 * OneKey Wallet provider adapter that implements IStellarProvider
 * using the OneKey Stellar API.
 */
const createOneKeyProvider = () => {
    const oneKeyProvider = getOneKeyStellarProvider();
    if (!oneKeyProvider) {
        throw new Error('OneKey Stellar provider not found');
    }
    const eventListeners = new Map();
    const wrappedCallbacks = new Map();
    return {
        close: () => {
            // Remove all event listeners using the wrapped callbacks
            eventListeners.forEach((callbacks, event) => {
                const oneKeyEventMap = {
                    accountChanged: 'accountChanged',
                    networkChanged: 'networkChanged',
                };
                const oneKeyEvent = oneKeyEventMap[event] || event;
                callbacks.forEach((callback) => {
                    const wrappedCallback = wrappedCallbacks.get(callback);
                    if (wrappedCallback) {
                        oneKeyProvider.removeListener(oneKeyEvent, wrappedCallback);
                        wrappedCallbacks.delete(callback);
                    }
                });
            });
            eventListeners.clear();
        },
        connect: () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const response = yield oneKeyProvider.getAddress();
            return (_a = response === null || response === void 0 ? void 0 : response.address) !== null && _a !== void 0 ? _a : '';
        }),
        disconnect: () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            oneKeyProvider.disconnect();
        }),
        getNetwork: () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            const network = yield oneKeyProvider.getNetwork();
            // Normalize network name to match expected format
            const networkUpper = network.toUpperCase();
            if (networkUpper.includes('TESTNET')) {
                return 'TESTNET';
            }
            if (networkUpper.includes('FUTURENET')) {
                return 'FUTURENET';
            }
            return 'PUBLIC';
        }),
        isUnlocked: () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            try {
                // Try to get address to check if wallet is unlocked
                yield oneKeyProvider.getAddress();
                return true;
            }
            catch (_b) {
                return false;
            }
        }),
        on: (event, callback) => {
            var _a;
            if (!eventListeners.has(event)) {
                eventListeners.set(event, new Set());
            }
            (_a = eventListeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(callback);
            // Map Stellar events to OneKey events
            const oneKeyEventMap = {
                accountChanged: 'accountChanged',
                networkChanged: 'networkChanged',
            };
            const oneKeyEvent = oneKeyEventMap[event] || event;
            const wrappedCallback = (...args) => {
                // OneKey might pass different data structures, extract what we need
                if (event === 'accountChanged') {
                    callback(args[0]);
                }
                else if (event === 'networkChanged') {
                    callback(args[0]);
                }
                else {
                    callback(args[0]);
                }
            };
            wrappedCallbacks.set(callback, wrappedCallback);
            oneKeyProvider.on(oneKeyEvent, wrappedCallback);
        },
        sign: (transactionXdr, options) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            const signedXdr = yield oneKeyProvider.signTransaction(transactionXdr, {
                network: options === null || options === void 0 ? void 0 : options.network,
                networkPassphrase: options === null || options === void 0 ? void 0 : options.networkPassphrase,
            });
            return signedXdr !== null && signedXdr !== void 0 ? signedXdr : '';
        }),
        signMessage: (message) => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            var _c;
            const signature = yield oneKeyProvider.signMessage(message);
            return String((_c = signature === null || signature === void 0 ? void 0 : signature.signedMessage) !== null && _c !== void 0 ? _c : '');
        }),
    };
};

exports.createOneKeyProvider = createOneKeyProvider;

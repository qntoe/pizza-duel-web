'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { Horizon, Networks, TransactionBuilder } from '@stellar/stellar-sdk';
import { Logger } from '@dynamic-labs/logger';
import { DynamicError } from '@dynamic-labs/utils';
import { WalletConnectorBase } from '@dynamic-labs/wallet-connector-core';
import { StellarWallet } from '../../wallet/StellarWallet.js';
import { getNetworkFromAddress } from '../../utils/getNetworkFromAddress.js';
import { StellarUiTransaction } from '../../utils/StellarUiTransaction/StellarUiTransaction.js';
import { StellarLocalStorageCache } from '../../StellarLocalStorageCache.js';

const HORIZON_MAINNET_URL = 'https://horizon.stellar.org';
const HORIZON_TESTNET_URL = 'https://horizon-testnet.stellar.org';
/**
 * Abstract base class for all Stellar wallet connectors.
 *
 * This class provides the common functionality needed by all
 * Stellar wallet implementations. It handles connection management,
 * network operations, and transaction signing.
 */
class StellarWalletConnector extends WalletConnectorBase {
    constructor(name, opts) {
        var _a;
        super({
            metadata: opts.metadata,
            walletBook: opts.walletBook,
        });
        this.name = 'Stellar';
        this.ChainWallet = StellarWallet;
        this.connectedChain = 'STELLAR';
        this.supportedChains = ['STELLAR'];
        /** Connection state */
        this.isConnecting = false;
        /** Flag to track if connection was cancelled by disconnect */
        this.connectionCancelled = false;
        this.name = name;
        this.logger = new Logger(this.name);
        this.stellarNetworks = (_a = opts.stellarNetworks) !== null && _a !== void 0 ? _a : [];
        this.overrideKey = this.key;
        this.cache = new StellarLocalStorageCache(this.overrideKey);
    }
    getEnabledNetworks() {
        return this.stellarNetworks;
    }
    getSelectedNetwork() {
        var _a;
        return (_a = this.stellarNetworks) === null || _a === void 0 ? void 0 : _a[0];
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.getAddress();
            if (!address) {
                return undefined;
            }
            if (!this.stellarNetworks.length) {
                return undefined;
            }
            const network = yield getNetworkFromAddress(address, this.stellarNetworks[0]);
            if (!network) {
                return undefined;
            }
            this.selectedNetwork = this.stellarNetworks.find((n) => n.chainId.toString() === network);
            return network;
        });
    }
    /**
     * Checks if the provider is already connected.
     */
    isProviderConnected() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return false;
            }
            // Check if provider has an isConnected property (not part of IStellarProvider but some wallets have it)
            const providerWithConnection = provider;
            if (typeof providerWithConnection.isConnected === 'boolean') {
                return providerWithConnection.isConnected;
            }
            // Some providers have isConnected as a method
            if (typeof providerWithConnection.isConnected === 'function') {
                return providerWithConnection.isConnected();
            }
            // If we have a cached public key, assume connected
            return Boolean(this.connectedPublicKey);
        });
    }
    /**
     * Connects to the Stellar wallet.
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            // Avoid unnecessary connection attempts
            if (this.isConnecting) {
                this.logger.debug('[connect] Connection already in progress');
                return;
            }
            // Check if already connected
            if (yield this.isProviderConnected()) {
                this.logger.debug('[connect] Provider already connected');
                return;
            }
            this.isConnecting = true;
            this.connectionCancelled = false;
            this.logger.debug('[connect] Attempting to connect');
            try {
                const provider = this.getProvider();
                if (!provider) {
                    throw new DynamicError('No Stellar provider found');
                }
                const publicKey = yield provider.connect();
                // Check if disconnect was called while we were waiting for provider.connect()
                // This prevents a race condition where disconnect() clears state but connect()
                // subsequently sets connectedPublicKey
                if (this.connectionCancelled) {
                    this.logger.debug('[connect] Connection cancelled by disconnect');
                    return;
                }
                this.connectedPublicKey = publicKey;
                if (publicKey) {
                    yield this.cache.setConnectedAccount(publicKey, {
                        active: true,
                        additionalAddresses: [],
                    });
                }
                this.logger.debug('[connect] Connected successfully');
            }
            catch (error) {
                this.logger.error('[connect] Connection failed:', error);
                throw new DynamicError('Failed to connect to Stellar wallet');
            }
            finally {
                this.isConnecting = false;
            }
        });
    }
    /**
     * Disconnects from the wallet.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug('[disconnect] Disconnecting');
            // Cancel any ongoing connection attempt to prevent race condition
            // where connect() might set connectedPublicKey after we clear it
            if (this.isConnecting) {
                this.logger.debug('[disconnect] Cancelling ongoing connection attempt');
                this.connectionCancelled = true;
                this.isConnecting = false;
            }
            const provider = this.getProvider();
            if (!provider) {
                // Still clear state even if no provider
                this.connectedPublicKey = undefined;
                this.getAddressPromise = undefined;
                yield this.cache.clearConnectedAcccounts();
                return;
            }
            try {
                yield provider.disconnect();
            }
            catch (error) {
                this.logger.debug('[disconnect] Disconnect not supported or failed:', error);
            }
            // Clear all cached state
            this.connectedPublicKey = undefined;
            this.getAddressPromise = undefined;
            yield this.cache.clearConnectedAcccounts();
        });
    }
    /**
     * Signs a Stellar transaction XDR.
     */
    signTransaction(transactionXdr) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                throw new DynamicError('No Stellar provider found');
            }
            const network = yield this.getNetwork();
            const networkPassphrase = yield this.getNetworkPassphrase();
            return provider.sign(transactionXdr, {
                network,
                networkPassphrase,
            });
        });
    }
    /**
     * Signs a message.
     */
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            if (!provider) {
                return undefined;
            }
            return provider.signMessage(messageToSign);
        });
    }
    getHorizonServer() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const url = ((_b = (_a = this.stellarNetworks[0]) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toLowerCase().includes('testnet'))
                ? HORIZON_TESTNET_URL
                : HORIZON_MAINNET_URL;
            return new Horizon.Server(url);
        });
    }
    /**
     * Gets the network passphrase for the current network.
     * @returns The network passphrase string
     */
    getNetworkPassphrase() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f;
            // First, try to get network from provider
            const provider = this.getProvider();
            if (provider) {
                try {
                    const providerNetwork = yield provider.getNetwork();
                    if (!providerNetwork) {
                        throw new Error('Provider returned null or undefined network');
                    }
                    const networkUpper = providerNetwork.toUpperCase();
                    if (networkUpper === 'TESTNET' || networkUpper.includes('TESTNET')) {
                        return Networks.TESTNET;
                    }
                    if (networkUpper === 'FUTURENET' ||
                        networkUpper.includes('FUTURENET')) {
                        return Networks.FUTURENET;
                    }
                    if (networkUpper === 'PUBLIC' || networkUpper.includes('PUBLIC')) {
                        return Networks.PUBLIC;
                    }
                }
                catch (error) {
                    // Provider getNetwork failed, fall through to other checks
                    this.logger.debug('[getNetworkPassphrase] Provider getNetwork failed:', error);
                }
            }
            // Fall back to checking selectedNetwork name
            const networkName = (_c = (_b = (_a = this.selectedNetwork) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== null && _c !== void 0 ? _c : '';
            if (networkName.includes('testnet')) {
                return Networks.TESTNET;
            }
            if (networkName.includes('futurenet')) {
                return Networks.FUTURENET;
            }
            // Check Horizon server URL as last resort
            const horizonUrl = (_f = (_e = (_d = this.selectedNetwork) === null || _d === void 0 ? void 0 : _d.rpcUrls) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : '';
            if (horizonUrl.includes('testnet')) {
                return Networks.TESTNET;
            }
            if (horizonUrl.includes('futurenet')) {
                return Networks.FUTURENET;
            }
            // Default to mainnet/public
            return Networks.PUBLIC;
        });
    }
    isTestnet() {
        var _a, _b;
        const network = this.getSelectedNetwork();
        if (!network) {
            return Promise.resolve(false);
        }
        return Promise.resolve((_b = (_a = network.name) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('testnet')) !== null && _b !== void 0 ? _b : false);
    }
    /**
     * Gets the connected public key.
     */
    getConnectedPublicKey() {
        return this.connectedPublicKey;
    }
    /**
     * Fetches the public address from the wallet provider.
     * This method ensures the wallet is connected before fetching the address.
     * Override this method in child classes if the wallet has a custom way to fetch addresses.
     * @returns The public address from the wallet
     */
    fetchPublicAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const provider = this.getProvider();
            if (!provider) {
                return '';
            }
            // Ensure provider is connected
            yield this.connect();
            // After connection, try to get the public key from the provider
            // Different wallets may store it in different ways (not part of IStellarProvider but some wallets have these)
            const providerWithExtras = provider;
            if (providerWithExtras.publicKey) {
                return providerWithExtras.publicKey;
            }
            // Some wallets require calling getPublicKey()
            if (typeof providerWithExtras.getPublicKey === 'function') {
                return providerWithExtras.getPublicKey();
            }
            // If we still don't have it, the connectedPublicKey should have been set by connect()
            return (_a = this.connectedPublicKey) !== null && _a !== void 0 ? _a : '';
        });
    }
    /**
     * Gets the address from cache or fetches it from the wallet.
     * This implementation avoids prompting the user unnecessarily by checking cache first.
     * Uses promise caching to prevent multiple simultaneous calls.
     */
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            // If there's already a pending getAddress call, return the same promise
            // This prevents multiple simultaneous wallet prompts
            if (this.getAddressPromise) {
                try {
                    return yield this.getAddressPromise;
                }
                catch (error) {
                    this.logger.error('[getAddress] Error fetching address from promise cache:', error);
                    this.getAddressPromise = undefined;
                    // Fall through to try again
                }
            }
            // Return cached public key if already connected
            if (this.connectedPublicKey) {
                return this.connectedPublicKey;
            }
            // Create a new promise and cache it
            this.getAddressPromise = (() => __awaiter(this, void 0, void 0, function* () {
                try {
                    // Check cache first to avoid prompting the user
                    const cachedAccount = yield this.cache.getActiveAccount();
                    if (cachedAccount === null || cachedAccount === void 0 ? void 0 : cachedAccount.address) {
                        this.connectedPublicKey = cachedAccount.address;
                        return cachedAccount.address;
                    }
                    // Fetch from wallet provider
                    const address = yield this.fetchPublicAddress();
                    this.connectedPublicKey = address;
                    // Cache the address
                    if (address) {
                        yield this.cache.setConnectedAccount(address, {
                            active: true,
                            additionalAddresses: [],
                        });
                    }
                    return address !== null && address !== void 0 ? address : '';
                }
                finally {
                    // Clear the promise cache after completion
                    this.getAddressPromise = undefined;
                }
            }))();
            return this.getAddressPromise;
        });
    }
    /**
     * Clears all connected accounts from cache.
     */
    clearConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cache.clearConnectedAcccounts();
        });
    }
    /**
     * Gets connected accounts from cache.
     */
    getConnectedAccountsFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentAccount = yield this.cache.getActiveAccount();
            const allAccounts = yield this.cache.getConnectedAccounts();
            const allConnectedAddresses = Object.keys(allAccounts || {});
            if (!(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.address)) {
                return allConnectedAddresses;
            }
            return [
                currentAccount.address,
                ...allConnectedAddresses.filter((address) => address !== currentAccount.address),
            ];
        });
    }
    /**
     * Gets connected accounts.
     * Returns accounts from cache to avoid prompting the user.
     */
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getConnectedAccountsFromCache();
        });
    }
    /**
     * Gets additional addresses for a main address.
     */
    getAdditionalAddresses(mainAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!mainAddress) {
                return [];
            }
            const currentAccount = yield this.cache.getConnectedAccount(mainAddress);
            return (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.additionalAddresses) || [];
        });
    }
    /**
     * Sets additional addresses for a main address.
     */
    setAdditionalAddresses(mainAddress, additionalAddresses) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cache.setConnectedAccount(mainAddress, {
                additionalAddresses,
            });
        });
    }
    /**
     * Ends the session and clears connected accounts.
     */
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connectedPublicKey = undefined;
            this.getAddressPromise = undefined;
            this.connectionCancelled = false;
            yield this.cache.clearConnectedAcccounts();
        });
    }
    /**
     * Function used to create transactions in the SDK interface
     *
     * @param from - The sender's address (Stellar public key)
     * @returns A new StellarUiTransaction instance
     */
    createUiTransaction(from) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.validateActiveWallet(from);
            const horizonServer = yield this.getHorizonServer();
            const networkPassphrase = yield this.getNetworkPassphrase();
            if (!horizonServer) {
                throw new DynamicError('No Horizon server available');
            }
            return new StellarUiTransaction({
                from,
                horizonServer,
                networkPassphrase,
                onSubmit: (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (!transaction) {
                        throw new DynamicError('Transaction must be provided');
                    }
                    const signedXdr = yield this.signTransaction(transaction.toXDR());
                    const signedTransaction = TransactionBuilder.fromXDR(signedXdr, networkPassphrase);
                    const result = yield horizonServer.submitTransaction(signedTransaction);
                    return result.hash;
                }),
            });
        });
    }
}

export { StellarWalletConnector };

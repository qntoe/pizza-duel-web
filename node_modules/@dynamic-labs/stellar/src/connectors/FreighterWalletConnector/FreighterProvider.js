'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { requestAccess, getNetwork, isConnected, signTransaction, signMessage, WatchWalletChanges } from '@stellar/freighter-api';

/**
 * Freighter Wallet provider adapter that implements IStellarProvider
 * using the Freighter API.
 */
const createFreighterProvider = () => {
    let watcher;
    const eventCallbacks = new Map();
    let isWatcherStarted = false;
    const startWatcher = () => {
        if (isWatcherStarted) {
            return;
        }
        if (!watcher) {
            watcher = new WatchWalletChanges();
        }
        watcher.watch((params) => {
            const accountChangedCallbacks = eventCallbacks.get('accountChanged');
            const networkChangedCallbacks = eventCallbacks.get('networkChanged');
            if (accountChangedCallbacks && params.address !== undefined) {
                accountChangedCallbacks.forEach((callback) => {
                    callback(params.address);
                });
            }
            if (networkChangedCallbacks && params.network !== undefined) {
                networkChangedCallbacks.forEach((callback) => {
                    callback(params.network);
                });
            }
        });
        isWatcherStarted = true;
    };
    return {
        close: () => {
            watcher === null || watcher === void 0 ? void 0 : watcher.stop();
            eventCallbacks.clear();
            isWatcherStarted = false;
        },
        connect: () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const response = yield requestAccess();
            return (_a = response.address) !== null && _a !== void 0 ? _a : '';
        }),
        disconnect: () => __awaiter(void 0, void 0, void 0, function* () { return undefined; }),
        getNetwork: () => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            const response = yield getNetwork();
            return (_b = response.network) !== null && _b !== void 0 ? _b : 'PUBLIC';
        }),
        isUnlocked: () => __awaiter(void 0, void 0, void 0, function* () {
            var _c;
            const response = yield isConnected();
            return (_c = response.isConnected) !== null && _c !== void 0 ? _c : false;
        }),
        on: (event, callback) => {
            if (!eventCallbacks.has(event)) {
                eventCallbacks.set(event, new Set());
            }
            eventCallbacks.get(event).add(callback);
            startWatcher();
        },
        sign: (transactionXdr, options) => __awaiter(void 0, void 0, void 0, function* () {
            var _d;
            const response = yield signTransaction(transactionXdr, {
                networkPassphrase: options === null || options === void 0 ? void 0 : options.networkPassphrase,
            });
            return (_d = response.signedTxXdr) !== null && _d !== void 0 ? _d : '';
        }),
        signMessage: (message) => __awaiter(void 0, void 0, void 0, function* () {
            var _e;
            const response = yield signMessage(message);
            return String((_e = response.signedMessage) !== null && _e !== void 0 ? _e : '');
        }),
    };
};

export { createFreighterProvider };

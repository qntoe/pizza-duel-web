'use client'
import { __awaiter } from '../../../_virtual/_tslib.js';
import { StrKey, Asset } from '@stellar/stellar-sdk';
import { formatNumberText } from '@dynamic-labs/utils';
import { STROOPS_PER_XLM } from '../../consts/index.js';
import { buildPaymentTransaction } from '../buildPaymentTransaction.js';
import { createPaymentAsset } from '../createPaymentAsset.js';
import { getAccountBalance } from '../getAccountBalance.js';

/**
 * Stellar UI Transaction class for managing Stellar transactions in the UI.
 *
 * This class implements the IUITransaction interface and provides Stellar-specific
 * functionality for creating, formatting, and submitting transactions.
 */
class StellarUiTransaction {
    constructor({ onSubmit, from, horizonServer, networkPassphrase, }) {
        this.chain = 'STELLAR';
        this.data = undefined;
        this.fee = { gas: undefined };
        /**
         * Formats a non-native token value back to a string
         *
         * @param value - The value as bigint
         * @param decimals - The number of decimals for the token
         * @returns The formatted amount as string
         */
        this.formatNonNativeToken = (value, decimals) => (Number(value) / Number(Math.pow(10, decimals))).toString();
        this.from = from;
        this.onSubmit = onSubmit;
        this.horizonServer = horizonServer;
        this.networkPassphrase = networkPassphrase;
    }
    /**
     * Fetches the gas fee for the transaction.
     *
     * Stellar uses a fixed base fee per operation. The minimum fee is 100 stroops
     * (0.00001 XLM) per operation. We'll use this as our default estimate.
     *
     * @returns The gas fee for the transaction
     */
    fetchFee() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fee.gas)
                return;
            const transaction = yield this.createTransactionSafe();
            if (!transaction) {
                throw new Error('Could not create a valid Stellar transaction, check your address and value');
            }
            // Stellar has a fixed base fee per operation (100 stroops = 0.00001 XLM)
            // Payment transactions have 1 operation, so the base fee is 100 stroops
            this.fee.gas = BigInt(100);
        });
    }
    isGasSponsored() {
        return false;
    }
    /**
     * Parses a string amount into bigint stroops (XLM smallest unit, 1e7)
     *
     * @param input - The amount as a string (e.g., "1.5")
     * @returns The amount in stroops as bigint
     */
    parse(input) {
        const floatValue = parseFloat(input);
        const stroops = Math.round(floatValue * STROOPS_PER_XLM);
        return BigInt(stroops);
    }
    /**
     * Parses a non-native token amount with custom decimals
     *
     * @param input - The amount as a string
     * @param decimals - The number of decimals for the token
     * @returns The amount as bigint
     */
    parseNonNativeToken(input, decimals) {
        return BigInt(Math.floor(Number(input) * Math.pow(10, decimals)));
    }
    /**
     * Formats a bigint value (in stroops) to a human-readable XLM string
     *
     * @param value - The value in stroops
     * @param options - Formatting options including precision
     * @returns The formatted amount as string
     */
    format(value, { precision } = {}) {
        const xlmValue = Number(value) / STROOPS_PER_XLM;
        const decimalString = xlmValue.toLocaleString('fullwide', {
            maximumFractionDigits: 20,
            minimumFractionDigits: 0,
            useGrouping: false,
        });
        return formatNumberText(decimalString, { precision });
    }
    /**
     * Submits the transaction by creating it and calling onSubmit
     *
     * @returns The transaction hash from onSubmit
     */
    submit() {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = (yield this.createTransaction());
            return this.onSubmit(transaction);
        });
    }
    /**
     * Gets the balance of the sender's account in stroops
     *
     * @returns The balance as bigint in stroops
     */
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const account = yield this.horizonServer.loadAccount(this.from);
                const balanceString = getAccountBalance(account);
                // Balance comes back as a string with decimals (e.g., "100.5000000")
                // We need to convert it to stroops
                const xlmAmount = parseFloat(balanceString);
                const stroops = Math.floor(xlmAmount * STROOPS_PER_XLM);
                return BigInt(stroops);
            }
            catch (_a) {
                return BigInt(0);
            }
        });
    }
    /**
     * Validates that an address is a valid Stellar address format
     *
     * Stellar addresses are 56-character base32-encoded strings starting with 'G'
     *
     * @param address - The address to validate
     * @returns true if the address format is valid
     */
    validateAddressFormat(address) {
        if (address === 'dyn_send_transaction.multiple_recipients') {
            return true;
        }
        // Use Stellar SDK's built-in validation
        return StrKey.isValidEd25519PublicKey(address);
    }
    /**
     * Creates a transaction for sending XLM or tokens
     *
     * @returns The transaction or undefined if invalid
     */
    createTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { value, to, nonNativeAddress, nonNativeValue } = this;
            if (!to) {
                throw new Error('Destination is required');
            }
            if (!value && !nonNativeValue) {
                return undefined;
            }
            // Load the source account
            const sourceAccount = yield this.horizonServer.loadAccount(this.from);
            // Determine the asset to send
            let asset;
            let amount;
            if (nonNativeAddress && nonNativeValue !== undefined) {
                // Transfer non-native token
                // nonNativeAddress format: "CODE:ISSUER" or "CODE-ISSUER" (e.g., "USDC:GXXXXXXX..." or "USDC-GXXXXXXX...")
                const [code, issuer] = nonNativeAddress.split(/[:-]/);
                asset = createPaymentAsset({ code, issuer });
                amount = this.formatNonNativeToken(nonNativeValue, (_a = this.nonNativeDecimal) !== null && _a !== void 0 ? _a : 7);
            }
            else if (value) {
                // Transfer native XLM
                asset = Asset.native();
                amount = (Number(value) / STROOPS_PER_XLM).toString();
            }
            else {
                return undefined;
            }
            // Build the transaction
            return buildPaymentTransaction({
                amount,
                asset,
                networkPassphrase: this.networkPassphrase,
                sourceAccount,
                toAddress: to,
            });
        });
    }
    /**
     * Safely creates a transaction, returning undefined on error
     *
     * @returns The transaction or undefined if creation fails
     */
    createTransactionSafe() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.createTransaction();
            }
            catch (error) {
                return undefined;
            }
        });
    }
}

export { StellarUiTransaction };
